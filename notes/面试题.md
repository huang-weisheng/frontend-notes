	# VUE

#### **vue的生命周期是什么**

```
vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件创建、数据初始化、挂载、更新、销毁，这就是一个组件所谓的生命周期。
beforeCreate() 在实例创建之前执行，数据未加载状态
created() 在实例创建、数据加载后，能初始化数据，dom渲染之前执行
beforeMount() 虚拟dom已创建完成，在数据渲染前最后一次更改数据
mounted() 页面、数据渲染完成，真实dom挂载完成
beforeUpadate() 重新渲染之前触发
updated() 数据已经更改完成，dom 也重新 render 完成,更改数据会陷入死循环
beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行
```

#### 为什么要有生命周期

```
因为：VUE中MVVM思想、虚拟DOM等机制
所以：需要钩子函数/生命周期，从而方便开发、提升性能等
```

#### 那你说下什么是单页面应用SPA优缺点，如何选择

```
SPA优点：
    1.切换速度快、减少HTTP请求、便于加特效
    2.前后端分离便于后期扩展
    3.转场动画，也就是一个页面切换另一个页面  transition
SPA缺点：
    1. 不利于seo优化
	2. 初次加载耗时（注：这时候可能问vue首屏加载慢如何解决 见优化部分答案）SPA缺点：不利于SEO优化（就是百度可以搜到你）
MPA多页面的好处
概念：有多个页面，跳转方式是页面之间的跳转
优点：首屏加载快；seo优化好
缺点：跳转较慢；相对复杂，没有实现前后端分离
如何选择
根据项目需求，老板没有明确说直接用vue脚手架创建框架就行，
但是老板说需要seo优化则通过：Vue.js 服务器端渲染（nuxt.js）
```

#### 什么是计算属性和侦听器

```
计算属性：普通方法的升级版，有缓存
怎么用：在data同级定义computed对象来声明计算属性、调用不加小括号
侦听器：用来监控模型数据变化
 怎么用：在data同级定义watch对象声明侦听器、方法名就是data中的键、不能调用
 如何选：
  1 事件 和 封装减少视图代码冗余便于后期维护 先用普通方法
  2 上述多次执行耗时 计算属性优化
3 当需要监控模型数据改变 使用侦听器。例如：搜索、全选全不选等等
```

#### 什么是混入

```
是什么：vue中提供的解决组件代码冗余的技术，可以提起相同的普通方法、模型数据等
怎么用：Vue.mixin 或 mixins键来定义
实战用：后期项目的跳转、返回上一页、提示信息等等
```

#### 什么是vue组件

```
是什么：用来代替传统HTML的一种解决方案、里面还是HTML、JS、CSS
好处：倡导模块化、便于后期相互调用、从而减少代码冗余、方便维护
怎么用： Vue.component(组件名，{template, methods, data, ....})
```

#### 组件通信工作流

```
父传子： 子组件通过 props 属性，绑定父组件数据，实现双方通信
子传父：	将父组件的事件在子组件中通过 $emit 触发
兄弟	：1 创建bus总线 全局仓库
     	2 传递数据 bus.$emit
         3 接受数据 bus.$on
```

#### vue中的事件修饰符

```
事件修饰符：.stop、.prevent、.once等
键盘修饰符：.enter、.ctrl .enter等
```

#### 什么是路由懒加载

```
路由懒加载是通过异步的方式来加载对应的路由组件，提高页面相应速度
```

#### vue的路由使用步骤？

```
1.下载vue-router路由模块；
2.创建路由对象；
3.配置路由规则；
4.将路由对象注册为vue实例对象的成员属性；
```

#### http协议状态码301和302的区别

```
301 redirect: 301 代表永久性转移(Permanently Moved)
302 redirect: 302 代表暂时性转移(Temporarily Moved )
302重定向只是暂时的重定向，浏览器会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索浏览器认为新的网址是暂时的。
301重定向是永久的重定向，浏览器在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址
```

#### 谈谈你对虚拟DOM的理解？

```
就是用JS 的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点，因为浏览器工作机制，通过虚拟DOM提升性能。
```

#### 回流重绘

```
回流：重新布局
重绘：改变元素属性样式
```

#### 谈谈你对diff算法的理解？

```
diff算法是虚拟DOM技术的产物，核心思想是通过新旧虚拟DOM做对比，（即diff），将变化的地方更新在真实的DOM上，也需要diff高效执行对比的过程，从而降低时间复杂度为O(n).
步骤一：用JS对象模拟DOM树
步骤二：比较新旧虚拟DOM树的差异
步骤三：把差异应用到真正的DOM树上
```

#### v-for中有key值和没有key值的区别

```
它们区别主要在于虚拟DOM的复用，绑定key可以更好的复用，避免重复渲染
```

#### 请谈谈对http的理解

```
HTTP：超文本传输协议，主要由request请求 和response响应 组成，规定了计算机之间如何相互通信
项目开发中常遇到的
请求方式常用的有get、post、put、delete
HTTP状态码：...
请求头：expire、gzip、content-type等
```

#### HTTP状态码

```
100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK 请求成功
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理
301 Moved Permanently 永久性重定向。
302 Found 临时性重定向。
303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
304 Not Modified 浏览器缓存
400 BadRequest 参数有误。
401 Unauthorized 密码错误。
403Forbidden 没有权限。
404 NotFound 文件不存在。
500 InternalServer Error 服务器错误。
503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
```

#### vue实现数据双向绑定的原理

```
采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调
```

#### Created与Mounted的区别

```
Created：在dom渲染之前调用，通常初始化某些属性值，然后再渲染成视图。
Mounted：在dom渲染之后调用，初始化页面完成后，再对dom节点进行一些需要的操作。
```

#### vue中mounted和updated这两个生命周期怎么运行的

```
mounted 页面首次渲染完毕时触发
updated 模型数据更新时候触发
```

#### vue首屏加载过慢如何解决

```
1、路由懒加载（也就是要的时候的时候进行加载。
2、UI组件按需加载
3、webpack启用gzip压缩
```

#### 解释单向数据流和双向数据绑定

```
单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state；
双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度。
```

#### Vue 如何去除url中的 #

```
vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history。
需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面(重定向)。
```

#### $route和$router的区别

```
$router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法
$route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等
```

#### NextTick 是做什么的

```
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功
```

#### 计算属性computed 和事件 methods 有什么区别

```
我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的
不同点：
computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，method 调用总会执行该函数
```

#### watch和computed区别

computed结果会缓存,依赖于外界响应式依赖发生变化而变化
watch是直接监听某个属性,只要这个属性发生了变化,就会触发相应的函数回调,并且能获取到变更值以及变更之前的值

#### 清除keep-alive缓存

```
deactivated () { //清除keep-alive的缓存
    this.$destroy(true)
  }
```

#### 对比 jQuery ，Vue 有什么不同

```
jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发
```

#### vue-router 路由实现

```
路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能
```

#### Vue 中怎么自定义过滤器

```
可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值
Vue.filter('reverse', function (value) {
  return value.split('').reverse().join('')
})
<!-- 'abc' => 'cba' -->
<span v-text="message | reverse"></span>
过滤器也同样接受全局注册和局部注册
```

#### 对 keep-alive 的了解

```
keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染
<keep-alive>
  <component>
    <!-- 该组件将被缓存！ -->
  </component>
</keep-alive>
可以使用API提供的props，实现组件的动态缓存

钩子函数:activated deactivated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存
```

#### Vue 的核心是什么

```
数据驱动 组件系统
```

#### vue 等单页面应用的优缺点

```
优点：1.良好的交互体验 2.良好的前后端工作分离模式 3.减轻服务器压力
缺点：1.SEO难度较高 2.前进、后退管理 	3.初次加载耗时多
```

#### **vue-router有哪几种导航守卫**

```
1>全局守卫
a：router.beforeEach 全局前置守卫，进入路由之前
b：router.beforResolve 全局解析守卫，在beforeRouterEnter调用之后调用
c：router.afterEach 全局后置钩子，进入路由之后
2>路由独享守卫
如果不想全局配置守卫的话，可以为某些路由单独配置守卫
3>路由组件内的守卫
beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能获取组件实例 this，组件实例还没被创建
beforeRouteUpdate (2.2)路由复用同一个组件时,在当前路由改变，但是该组件被复用时调用 可以访问组件实例this
beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this
```

#### 你在什么场景下使用了vuex？

```
当应用遇到多个组件共享状态的时候，即：多个视图依赖于同一个状态，不同视图的行为需要变更同一个状态
如：
用户的个人信息管理模块
电商项目购物车模块
```

#### props和data的优先级，区别

```
props>data
props就相当于你的参数，data就相当于局部变量，组件其实就是一个函数
```

#### 地址栏输入一个url发生了什么

1.DNS解析寻址,将输入的url解析为ip地址
2.TCP三次握手:根据ip地址与服务器进行连接通信
3.发送HTTP请求,请求相关资源
4.服务器接收请求并返回HTTP报文,携带指定资源
5.浏览器解析资源,渲染页面
6.TCP四次挥手,关闭连接

#### js执行机制

a、首先 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。

b、在执行同步代码的时候，如果遇到了异步事件，会将异步代码放到事件循环中，继续执行执行栈中的其他任务;

c、当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行
d、任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行
e、当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务

# 原型，原型链

原型：js给每个函数分配的公共空间，减少内存占用

原型链：多个原型的集合，当调用对象的属性或方法时，先自身找，找不到去原型链上找，一直找到Object构造函数得原型链

# 其他

#### sass和less区别

```
1.编译环境不一样,less是基于JavaScript的在客户端处理 所以安装的时候用npm，sass是基于ruby所以在服务器处理。
2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。
Sass的功能比Less强大
```

#### **link和@import的区别**

```
1》link是html的标签，不仅可以加载css还可以定义Rss , rel连接属性；@import是css的语法规则，只能引入样式；
2》加载页面时，link是同时加载的，@impor是页面加载完后才加载
3》link没有兼容性的问题，而@import只在较高版本的浏览器才可以识别
4》link标签可以通过js插入，@import 不可以！
```

#### **如何理解js中的原型链**

```
1；每个构造函数都有一个原型对象
2；每个原型对象都有一个指向构造函数的指针
3；每个实例函数都有一个指向原型对象的指针。
4；查找方式是一层一层查找，直至顶层。Object.prototype
```

#### 图片懒加载原理

```
就是我们先设置图片的data-set属性（当然也可以是其他任意的，只要不会发送http请求就行了，作用就是为了存取值）值为其图片路径，由于不是src，所以不会发送http请求。 然后我们计算出页面scrollTop的高度和浏览器的高度之和， 如果图片举例页面顶端的坐标Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时候我们再将 data-set 属性替换为 src 属性即可。

或
好处：减少HTTP请求
1、监控滚动条滚动
2、获取总可视内容高度（可见视口高度+滚动条滚动高度）
3、获取所有图片
4、遍历步骤3
5、在步骤4中判断，图片.offsetTop <= 步骤2    成立-修改src属性为data-src、失败-不管
6、节流防抖优化
```

#### **react和vue有哪些不同，说说你对这两个框架的看法**

```
相同点:
· 都支持服务器端渲染
· 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范
· 数据驱动视图
· 都有支持native的方案,React的React native,Vue的weex
不同点:
· React严格上只针对MVC的view层,Vue则是MVVM模式
· virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制
· 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;
· 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的
· state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理
```

#### **px和em的区别**

```
相同点：px和em都是长度单位；
异同点：px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。
浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。
```

#### **JS哪些操作会造成内存泄露**

```
1）意外的全局变量引起的内存泄露
function leak(){  leak="xxx";//leak成为一个全局变量，不会被回收  }
2）闭包引起的内存泄露
3）没有清理的DOM元素引用
4）被遗忘的定时器或者回调
5）子元素存在引起的内存泄露
```

#### **浏览器缓存有哪些，通常缓存有哪几种**

```
http缓存
websql
cookie
localstorage
sessionstorage
flash缓存
```

#### **浏览器是如何渲染页面的？**

```
渲染的流程如下：
1.解析HTML文件，创建DOM树。
   自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。
2.解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式；
3.将CSS与DOM合并，构建渲染树（Render Tree）
4.布局和绘制，重绘（repaint）和重排（reflow）
```

#### **CSS3新增的属性**

```
CSS3实现圆角（border-radius），阴影（box-shadow），
对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
增加了更多的CSS选择器  多背景 rgba
在CSS3中唯一引入的伪元素是::selection.
媒体查询，多栏布局
border-image
```

#### **H5新特性**

```
(1)新的语义标签和属性
(2)表单新特性
(3)视频和音频
(4)Canvas绘图
(5)SVG绘图
(6)地理定位
(7)拖放API
```

#### 谈一下JS的继承

```
1.借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上
2.原型继承，将子对象的prototype指向父对象的一个实例
3.组合继承
原型链继承的缺点:
字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。
借用构造函数（类式继承）:
借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。
组合式继承:
组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
```

#### 跨域的解决方法

```
前端:1.浏览器插件2.前端代理3.JSONP
后端:1.声明header头2.后端代理
运维:web服务器配置
等等
```

#### 谈谈你对闭包的理解

```
使用闭包主要是为了设置私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念
闭包有三个特性：
1.函数嵌套函数
2.函数内部可以引用外部的参数和变量
3.参数和变量不会被垃圾回收机制回收
```

#### 做过哪些性能优化

```
1 尽量减少HTTP请求次数
2 压缩合并js
3 css精灵
4 减少DOM元素数量
5 使用CDN(网站上静态资源即css、js全都使用cdn分发，图片亦然,因为cdn拥有众多服务器，用户请求可以请求距离他近的服务器，加快速度)
6 把CSS放到顶部,把JS放到底部
7 使用gzip压缩内容(服务端)
```

#### BFC的理解

```
 BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。
```

#### 关于配置webpack的了解？

```
它属于一个预编译模块方案（模块打包工具），我们现在的前端代码开始分模块进行构建，则会用到import "./a.js"; 、require ("a.js"); 等方法。但是浏览器是不认识这样的方法。这时，webpack 就出现了，它采用预编译的方式，在代码加载到页面前，把这些模块引用的方式转换成浏览器可以识别的js代码。
```

#### 怎么配置cli的三种环境？

```
1.创建环境env文件
2.修改package.json
3.vue.config.js中引用环境变量
```

#### 组件的预加载，说几种方式。

```
1、使用import导入组件，可以获取到组件
2、使用import导入组件，直接将组件赋值给componet
3、使用require 导入组件，可以获取到组件
4、使用require 导入组件，直接将组件赋值给componet
```

#### mpvue遇到的坑

```
1.文件夹名字不能大写。
2.两层v-for不能用index的名字来作为索引
3.合法域名校验出错，不在以下合法域名列表中
```

#### 函数的this指向，bind call apply 的区别  bind怎么立即调用，call apply怎么延迟调用

```
A普通函数调用   	this =>  window
B对象函数调用   	this =>  对象本身
C事件处理函数调用  this =>  事件源
D定时器调用       this =>  window
E箭头函数中调用    this  =>  父function中的this    父没有function则window
F bind/apply/call this=>   用来改变this指向

区别：都用来改变this的指向，bind后函数不会执行，而只是返回一个改变了上下文的另一个函数，而call和apply是直接执行函数。若无参数，apply与call基本没什么区别
```

#### es6

```
1.不一样的变量声明：const和let
2.模板字符串
3.箭头函数（Arrow Functions）
4. 函数的参数默认值
5.Spread / Rest 操作符
6.二进制和八进制字面量
7.对象和数组解构
8.对象超类
9.for...of 和 for...in
10.ES6中的类
```

#### Promise是什么   和 async await的区别 async await 的底层

```
Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的

区别：
1 Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。
2 async await与Promise一样，是非阻塞的。
3 async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。
```

#### Echarts是什么

```
商业级数据图表，它是一个纯JavaScript的图标库，兼容绝大部分的浏览器，底层依赖轻量级的canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。
Echarts支持的图表：折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）
雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等12类图表
```

#### 清除浮动的几种方法

```
1，额外标签法，<divstyle="clear:both;"></div>（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）
2，使用after伪类
#parent:after{
content:".";
height:0;
visibility:hidden;
display:block;
clear:both;
}
3,浮动外部元素
4,设置overflow为hidden或者auto
```

#### Commonjs的理解

```
CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作
```

#### 请解释什么是事件代理

```
事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。
事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。
```

#### 创建ajax过程

```
ajax(异步javascript xml) 是什么：能够刷新局部网页数据而不是重新加载整个网页。
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
(3)设置响应HTTP请求状态变化的函数.
(4)发送HTTP请求.
(5)获取异步调用返回的数据.
(6)使用JavaScript和DOM实现局部刷新.
```

#### 为什么HTTPS安全

```
因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性
```

#### 说一下cookie和session的区别

```
性能角度: 	 cookie影响性能    h5不影响性能    h5最重要
生命周期:    cookie自定义      localStorage永久、sessionStorage窗口
存储空间：	cookie 4k      h5  5M
主要网站设置了cookie  后期所有请求都会携带cookie 影响性能
```

#### 数组去重的方法

```
一、利用ES6中的 Set 方法去重
二、使用双重for循环，再利用数组的splice方法去重（ES5常用）
三、利用数组的indexOf方法去重
四、利用数组的sort方法去重（相邻元素对比法）
五、利用ES6中的Map方法去重
六、利用数组的filter方法去重
```

#### export和export default的区别？

```
使用上的不同
export default  xxx
import xxx from './'

export xxx
import {xxx} from './'
```

#### get、post的区别

```
1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&进行参数分割。psot将参数存放在HTTP的包体内
2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制
3.get后退不会有影响，post后退会重新进行提交
4.get请求可以被缓存，post不可以被缓存
5.get请求只URL编码，post支持多种编码方式
6.get请求的记录会留在历史记录中，post请求不会留在历史记录
7.get只支持ASCII字符，post没有字符类型限制
```

#### 优雅降级和渐进增强

```
渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。
优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。
```

### 将一个div盒子水平垂直居中

```
    .parent{
        width: 500px;
        height: 500px;
        border: 1px solid red;
    }
    .child{
        width: 100px;
        height: 100px;
        border: 1px slid #111;
    }


     <div class="parent">
         <div class="child"></div>
     </div>


方法一：利用定位（常用方法,推荐）

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:50%;

    left:50%;

    margin-top:-50px;

    margin-left:-50px;

    }

方法一的原理就是定位中心点是盒子的左上顶点，所以定位之后我们需要回退盒子一半的距离。



方法二：利用margin:auto;

.parent{

    position:relative;

    }

.child{

    position:absolute;

    margin:auto;

    top:0;

    left:0;

    right:0;

    bottom:0;

    }

方法三：利用display:table-cell;

.parent{

    display:table-cell;

    vertical-align:middle;

    text-align:center;

    }

.child{

    display:inline-block;

    }

方法四：利用display：flex;设置垂直水平都居中；

.parent{

    display:flex;

    justify-content:center;

    align-items:center;

    }

方法五：计算父盒子与子盒子的空间距离(这跟方法一是一个道理)；

计算方法：父盒子高度或者宽度的一半减去子盒子高度或者宽的的一半。

.child{

    margin-top:200px;

    margin-left:200px;

    }

方法六：利用transform

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:50%;

    left:50%;

    transform:translate(-50%,-50%);

    }

方法七：利用calc计算

.parent{

    position:relative;

    }

.child{

    position:absolute;

    top:calc(200px);//（父元素高-子元素高）÷ 2=200px

    let:calc(200px);//（父元素宽-子元素宽）÷ 2=200px

    }
```

# Vue中更新是异步还是同步的,为什么?

- 数据是同步更新，视图是异步更新
- 因为如果视图更新是同步的，那会导致多次渲染浪费不必要的性能，没必要，内部做了去重(重新更新的值)和防抖(只更新最后一次)

# 什么是Promise

Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法 可以很好地解决**回调地狱**的问题（避免了层层嵌套的回调函数） ， 语法非常简洁

`Promise`对象有以下两个特点。

特点1： 对象的状态不受外界影响。

​ 解释： `Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和 rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无 法改变这个状态。

特点2： 一旦状态改变，就不会再变，任何时候都可以得到这个结果。

​ 解释：Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要 这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定 型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。

## 单行文本溢出，显示省略号

```
.div_text{
             width: 300px;
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
             }
```

## 多行文本溢出，显示省略号

```
 .div_moreline{
            width: 300px;
            display:-webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3;
            overflow: hidden;
            max-height: 90px;
            }
```

# vue-cli3.0兼容2.0版本

npm install -g @vue/cli-init

# 什么时候视图不会更新?

```
//1.操作数组的索引
//2.操作数组的length
//以上两种情况都不会更新视图
```

# 为什么操作这两个属性不会更新视图?

```
//原因就是因为Vue2.0底层响应式原理使用了ES5中的Object.defineProperty()这个方法,这个方法有个缺点,缺点就是无法劫持数组,数组的变化是没有办法进行响应
    //操作一些数组的方法 比如push pop shift unshift reverse等方法会触发视图的更新,因为vue的底层特别对这几个方法做了hack处理,只要我们调用这些方法也会视图的更新
    //Vue3.0的版本,使用的proxy这个方法,这个方法可以劫持数组,就不会出现操作索引和length不更新视图的情况了
```

# 怎么处理不更新的问题?

```
 //1.不要操作数组的length和索引,如果说硬要操作,可以使用Vue.$set(target,key,value)方法
 //2.如果说操作了这些属性,不知道问题在哪里,解决不了视图不更新的情况,我们可以调用强制更新$forceUpdate()
```

# v-for中有个属性,key,key的作用是什么?

```
用于区分diff算法的时候,元素的唯一性
//key的值,正常情况下一般都要给一个唯一的值,如果没有一个惟一的情况下,那么可以暂时的使用index来代替
//写项目的时候,后台返回的数据肯定有id,那么这个id就是唯一的标识所以我们一般使用id来作为key的值
```

# v-model的修饰符 ?

```
trim lazy number
```

# V-if v-show的区别 以及使用场景

```
//v-if 都是用于控制元素/组件的显示和隐藏 值都是布尔值,如果布尔值为true那么元素就会显示,如果为false,那么元素或者组件就会隐藏 v-if元素不显示的时候,dom结构也会一并移除
//v-if可以和v-else v-else-if结合使用,如果v-if布尔值为true,那么不会展示v-else的内容,如果布尔值为false,那么就会展示v-else,而不会展示v-if,两者的关系,就是老死不相往来,互斥
//v-show  都是用于控制元素/组件的显示和隐藏 值都是布尔值,如果布尔值为true那么元素就会显示,如果为false,那么元素或者组件就会隐藏 v-show隐藏元素之后,不会移除dom结构

//使用场景:首次渲染开销较大的时候,可以使用v-if 频繁切换的时候使用v-show
```

# v-on的修饰符

```
//prevent 阻止默认事件
//ocne 只调用一次
//native 触发组件根元素的原生事件
```

# 定义自定义指令的方式,以及自定义指令的钩子函数

```
//bind
//inserted
//update
```

# 计算属性的特点?

```
 //1.计算的结果会缓存
 //2.根据外界响应式依赖发生变化而变化
```

# watch监听的三种情况和写法

```
普通监听
深度监听
字符串写法
```

# 组件的通信方式 写出所有的

```
父子传值：props
子父传值:$emit
eventbus
refs
$root
$parent
vueX

```

# 在组件上使用v-model流程

```
父组件:子标签上v-model="val"
子组件:input标签上动态绑定value :value="value"
注册事件input
@input: 'ipt'
在methods中定义ipt事件，接收参数
    ipt(e){
        this.$emit('input',e.target.value)
    }
原理:语法糖默认接受value的props，默认发射input的事件出去
```

# 封装组件的流程

```
 1.使用Vue.extend()创建一个组件

 2.使用Vue.component()方法注册组件

 3.如果子组件需要数据，可以在props中接受定义

 4.子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法
```

# slot具名插槽 插槽作用域

```
1.具名插槽：给slot加上name属性，添加内容时，标签上 v-slot:name属性值
    举例：
    <div id="app">
            <sdh-com>
                <template v-slot:header>
                    <div class="header">
                        <h1>这是顶部栏</h1>
                    </div>
                </template>
            </sdh-com>
     </div>
    <template id="sdh">
        <fieldset>
            <div id="header">
                <slot name="header"></slot>
            </div>
        </fieldset>
    </template>

     <script>
         Vue.component('sdh-com', {
            data() {
                return {

                }
            },
            template: '#sdh'
        })

        const vm = new Vue({
            el: "#app",
            data: {

            }
        })
    </script>


2.插槽作用域：将组件内部的数据传递给分发的内容进行渲染，再通过solt接收分发内容
	举例：
		<!DOCTYPE html>
        <html lang="en">

        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>03.插槽slot.html</title>
        </head>

        <body>
            <div id="app">
                <sdh-com>
                    <template v-slot="{arr}">
                        <ul>
                            <li v-for="(item,index) in arr" :key="index">{{item}}</li>
                        </ul>
                    </template>
                </sdh-com>
            </div>
        </body>

        </html>

        <template id="sdh">
            <fieldset>
                <legend>苏大海</legend>
                <h1>{{girlFriend}}</h1>
                <slot :arr="arr"></slot>
            </fieldset>
        </template>

        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
        <script>
            //插槽作用域
            //将组件内部的数据传递给分发的内容进行渲染
            //再通过solt接收分发内容
            Vue.component('sdh-com', {
                data() {
                    return {
                        girlFriend: '乔姑娘',
                        arr: ["黄瓜", '香蕉', '茄子', '山药', '莲藕']
                    }
                },
                template: '#sdh'
            })

            const vm = new Vue({
                el: "#app",
                data: {
                    msg: "那是"
                }
            })
        </script>


```

# Mixins合并策略

```
//1.如果说混入了data属性,那么会对data进行递归合并,冲突的时候,以组件的属性优先

//2.同名的钩子函数会被合并为一个数组,都会进行调用,会以混入对象的钩子函数优先调用

//3.组件选项 比如methods directives components filters...都会被合并为一个对象,冲突的时候,以组件的键值对为主
```

# beforeDestroy和destroyed一般用来做什么?

```
销毁定时器，解绑全部指令及事件监听，清除全局事件等
```

# keep-alive的作用以及使用方式 钩子函数 以及两个属性的用法

```
作用:缓存组件
钩子函数:activated deactivated
属性:include包含的组件会被缓存，exclude排除的组件不会被缓存

```

# 父组件的beforeUpdate触发了会不会触发子组件的beforeUpdate?

```
不会
```

# 为什么beforeCreate不能发请求?

```
因为$data都还没初始化,就算获得了后台数据,也不能修改data
```

# 什么是虚拟dom?

```
通过js模拟真实dom的嵌套,创建踹的结构,就是虚拟dom,在内存中,页面是看不见的,只有添加到页面上才能看见
```

# 为什么要使用虚拟dom?

```
使用虚拟dom,可以在内存中更新结构,而不是操作真实dom一个一个更新,最大的好处提高页面渲染的性能,结合diff算法 让页面进行高效更新
```

# Vue响应式的原理是什么?

```
　　Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。
```

# 32.触发回流的条件 触发重绘的条件?

```
# 回流
1. 位置的改变 translate 定位的left top
2. 元素位置的显示和隐藏也会引起回流
3. 宽高的变化
# 重绘
1. 颜色的变化
2. 字体风格的变化
3. 背景的变化
```

# 34.单页应用的有点和缺点?

```
用户体验好,切换速度快,不需要刷新整个页面
```

# 36.History hash abstract模式的区别?

```
1. hash有#号,#号后面的url不会向后端发起请求

2. hash路由使用onhashchange监听 history使用onpopstate监听

3. history使用的是H5的api pushState replaceState
4. 当hash值相同时,不会触发hashchange,history当输入相同的路径的时候,会将浏览器中的地址当成是请求地址向后台发送请求,会造成页面404
5. abstract模式是在没有浏览器api的情况下自动启用,abstract模式在切换页面的时候,路径是不会发生变化的

6. 关键字 onhashchange pushstate replacestate popstate
7.
```

# 37.动态路由参数解耦合步骤

```
再path路径下，通过props:true解耦，使用，通过props:['动态参数']
```

# 网络安全

## XSS攻击

> **跨网站指令码**（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是[代码注入](https://www.wikiwand.com/zh-hans/代碼注入)的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。

XSS 分为三种：反射型，存储型和 DOM-based

### 如何攻击

XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。

例如通过 URL 获取某些参数

```html
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
```

上述 URL 输入可能会将 HTML 改为 `alert(1)` ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。

也有另一种场景，比如写了一篇包含攻击代码 `alert(1)` 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。

### 如何防御

最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

```js
function escape(str) {
  str = str.replace(/&/g, '&amp;')
  str = str.replace(/</g, '&lt;')
  str = str.replace(/>/g, '&gt;')
  str = str.replace(/"/g, '&quto;')
  str = str.replace(/'/g, '&#39;')
  str = str.replace(/`/g, '&#96;')
  str = str.replace(/\//g, '&#x2F;')
  return str
}
```

通过转义可以将攻击代码 `alert(1)` 变成

```js
// -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt;
escape('<script>alert(1)</script>')
```

对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

```js
var xss = require('xss')
var html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html)
```

以上示例使用了 `js-xss` 来实现。可以看到在输出中保留了 `h1` 标签且过滤了 `script` 标签

### CSP攻击

> 内容安全策略 ([CSP](https://developer.mozilla.org/en-US/docs/Glossary/CSP)) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 ([XSS](https://developer.mozilla.org/en-US/docs/Glossary/XSS)) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。

我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。

通常可以通过 HTTP Header 中的 `Content-Security-Policy` 来开启 CSP

- 只允许加载本站资源

  ```http
  Content-Security-Policy: default-src ‘self’
  ```

- 只允许加载 HTTPS 协议图片

  ```http
  Content-Security-Policy: img-src https://*
  ```

- 允许加载任何来源框架

  ```http
  Content-Security-Policy: child-src 'none'
  ```

更多属性可以查看 [这里](https://content-security-policy.com/)

## CSRF攻击

> **跨站请求伪造**（英语：Cross-site request forgery），也被称为 **one-click attack** 或者 **session riding**，通常缩写为 **CSRF** 或者 **XSRF**， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[[1\]](https://www.wikiwand.com/zh/跨站请求伪造#citenoteRistic1)
> 跟[跨網站指令碼](https://www.wikiwand.com/zh/跨網站指令碼)（XSS）相比，**XSS** 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

简单点说，CSRF 就是利用用户的登录态发起恶意请求。

### CSRF漏洞现状

CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI......而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。

### 如何攻击

假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口

```html
<img src="http://www.domain.com/xxx?comment='attack'" />
```

如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口

```html
<form action="http://www.domain.com/xxx" id="CSRF" method="post">
  <input name="comment" value="attack" type="hidden" />
</form>
```

### 如何防御

防范 CSRF 可以遵循以下几种规则：

1. Get 请求不对数据进行修改
2. 不让第三方网站访问到用户 Cookie (httponly:true;ali.com)
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，比如验证码或者 token

#### SameSite

可以对 Cookie 设置 `SameSite` 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

#### 验证 Referer

对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。

#### Token

服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。

## 密码安全

密码安全虽然大多是后端的事情，但是作为一名优秀的前端程序员也需要熟悉这方面的知识。

### 加盐

对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。

通常需要对密码加盐，然后进行几次不同加密算法的加密。

```js
// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)))
```

但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。

# vue中的render函数介绍

**render函数是什么** ：

​ 简单的说，在vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用js语言来构建DOM

​ 因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue 就免去了转译的过程。

​ 使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。

# **MVVM和MVC的区别**

MVC和MVVM的区别其实并不大。都是一种设计思想。

主要就是MVC中Controller演变成MVVM中的viewModel。

MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验。

当和Model频繁发生变化，开发者需要主动更新到View。

**MVVM设计模式的优点**

1. 双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好的做到数据的一致性

2. 由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身

3. View的功能进一步强化，具有控制的部分功能，

   若想无限增强它的功能，甚至控制器的全部功能几乎都可以迁移到各个View上

（不过这样不可取，那样View干不了属于它职责范围内的事情）。

View可以像控制器一样具有自己都View-Model

4. 可以对View或ViewController的数据处理部分抽象出来一个函数处理model。

   这样它们专职页面布局和页面跳转，它们必然更一步的简化。

**MVVM设计模式的缺点**

1. 数据绑定也使得bug很难被调试。比如你看到页面异常了，有可能是你的View的代码有bug，也可能是你的model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。

2. 数据双向绑定不利于代码重用。客户端开发最常用的是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同的模块model都不同。那就不能简单重用view了

3. 一个大的模块中model也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。

   #

# let、const、var的区别

    const声明的是常量，必须赋值
        1）一旦声明必须赋值,不能使用null占位。
        2）声明后不能再修改
        3）如果声明的是复合类型数据，可以修改其属性

    let和var声明的是变量，声明之后可以更改，声明时可以不赋值

    var允许重复声明变量，后一个变量会覆盖前一个变量。

    let和const在同一作用域不允许重复声明变量，会报错。

    var声明的变量存在变量提升（将变量提升到当前作用域的顶部）。即变量可以在声明之前调用，值为undefined。
    let和const不存在变量提升。即它们所声明的变量一定要在声明后使用，否则报ReferenceError错。


    var：只有全局作用域和函数作用域概念，没有块级作用域的概念。但是会把{}内也假称为块作用域。
    let const：只有块级作用域的概念 ，由 { } 包括起来，if语句和for语句里面的{ }也属于块级作用域。
    ES5中作用域有：全局作用域、函数作用域。没有块作用域的概念。
    ES6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。

    ES6明确规定：如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
                所以在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

```

<input v-model="a" />
input元素
<input :value="a" @input="a = $event.target.value" /> // $event.target.value
就是把input的值赋值给 a

对于非input元素
如果在自定义组件中，v-model
默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：

父组件：
<ModelChild v-model="message"></ModelChild>

子组件：
<div>{{value}}</div>
props:{ value: String },
methods: {
    test1(){
        this.$emit('input', '小红')
    },
},
```

，

# ■ 符号说明

💘 课题

🌟 常见重要

🌛 需要有印象的

🆕 v3新特性

# 01-基本语法

## 💘 课题

01-Vue基础（基本语法：简介、模板语法、列表渲染、条件渲染、事件处理）

## 🆕 先学vue3基本语法

```
<div id="root">
    <h1>{{msg}}</h1>

    <input type="text" v-model="content" />
    <button @click="addFn">添加</button>

    <ul>
        <li v-for="item in todos">{{item.id}} {{item.title}}</li>
    </ul>
</div>
<script src="https://unpkg.com/vue@next"></script>
<script>
// 以前：new Vue({el,data,methods....})
// 以前：new Vue({data,methods....}).$mount('#root')
// 现在：Vue.createApp({data,methods}).mount('#root')

Vue.createApp({
    data() {
        return {
            msg: "hello vue3",

            content: '',
            todos: [
                {id:1, title: '吃饭'},
                {id:2, title: '睡觉'},
                {id:3, title: '挤痘痘'},
            ]
        }
    },
    methods: {
        addFn() {
            this.todos.push({
                id: this.todos.length,
                title: this.content
            })
        }
    }
}).mount('#root')
</script>
```

## 🌟 说出vue常用的指令

```
{{data中的键}}
v-text
v-html
v-bind  简写 :
v-for
v-if、v-else-if、v-else
v-show
v-on   简写 @

v-pre   跳过编译
v-once  仅渲染一次
v-clock 插值闪烁问题

v-model
```

## 🌟 MVVM、MVC面试题

- 谈谈你对MVC的理解

```
MVC是软件开发中常见的开发模式，主要应用于后端，将程序划分为M模型、V视图、C控制器从而便于团队协作开发，减少代码冗余
```

- 谈谈你对MVVM理解

```
MVVM是Model-View-ViewModel缩写，也就是将MVC中的Controller演变成ViewModel
Model层代表数据模型、
View层代表UI组件
ViewModel是Model、View层的桥梁，数据会绑定到ViewModel并自动将数据渲染到页面，视图变化会通知ViewModel层更新数据。

或者

随着移动互联网的发展，MVVM思想借鉴MVC、MVP思想演变而来，M模型负责数据维护，V视图负责数据展示，VM则是M和V的桥梁，监控M模型数据变化自动更新V视图，从而解决传统前后端分离JQ架构弊端

开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。
大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。
```

- 谈谈MVVM和MVC区别

```
相同点：都是软件开发常见的开发模式或者开发思想
不同点：
1- MVC后端居多，MVVM前端
2- MVC单向通信 目的将M和V代码分离，MVVM则是双向通信，不需要手动操作DOM

或

最初MVC最早出现在后端   M代表模型负责数据处理、V代表视图负责数据战士、C代表控制器负责调度
后来前端也有了MVC库，最早实现的就是backbone.js 但是V和M并没有很好的解耦
因此出现了MVVM模式，
MVVM是Model-View-ViewModel缩写，也就是将MVC中的Controller演变成ViewModel
Model层代表数据模型、
View层代表UI组件
ViewModel是Model、View层的桥梁，数据会绑定到ViewModel并自动将数据渲染到页面，视图变化会通知ViewModel层更新数据。
```

## 🌟 说一下v-show、v-if的区别

相同点：都可以用户判断控制元素隐藏显示

不同点：1-v-if语法更强、2-v-if控制DOM、v-show控制CSS

如何选：高频切换例如二维码、登录弹框、提示框、删除提示框、tab选项卡，推荐使用v-show 来减少DOM频繁删除创建所产生的额外性能开销

高逼格

```
v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。
所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。
```

## 🆕 判断循环v-if、v-for优先级

- 手册

```
https://cn.vuejs.org/v2/guide/list.html#v-for-%E4%B8%8E-v-if-%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8
https://cn.vuejs.org/v2/guide/conditional.html#v-if-%E4%B8%8E-v-for-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8
```

- 在 vue 2.x 中，在一个元素上同时使用 `v-if` 和 `v-for` 时， `v-for` 会优先作用。
- 在 vue 3.x 中， `v-if` 总是优先于 `v-for` 生效。


- vue2

```
<div id="root">
    <h1>vue2 v-for>v-if</h1>

    <div v-if="state">
    	<p v-for="item in todos">{{item.title}}</p>
    </div>

    <p v-for="item in todos" v-if="state">{{item.title}}</p>

</div>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
const vm = new Vue({
    el: "#root",
    data: {
        todos: [
        		state: false,

            {id:1, title:'a'},
            {id:2, title:'b'},
            {id:3, title:'c'},
        ]
    }
})
</script>
```

- vue3 优化

```
<div id="root">
    <h1>vue3 v-if > v-for</h1>


    <div v-if="state">
    	<p v-for="item in todos">{{item.title}}</p>
    </div>

    <p v-for="item in todos" v-if="state">{{item.title}}</p>

    <!-- 多学一招 -->
    <template v-if="state">
    	<p v-for="item in todos">{{item.title}}</p>
    </template>
</div>
<script src="https://unpkg.com/vue@next"></script>
<script>
Vue.createApp({
    data() {
        return {
            todos: [
                {id:1, title:'a', show: true},
                {id:2, title:'b', show: false},
                {id:3, title:'c', show: true},
            ]
        }
    }
}).mount('#root')
</script>

```

# 02-特殊语法

## 💘 课题

02-Vue基础（特殊语法：表单输入绑定、购物车案例）

无，都在第三天

# 03-语法原理

## 💘 课题

03-Vue高级（语法原理：v-model语法原理、响应式原理、Vue源码分析、自定义Vue库）

## 🌟 说一下v-model原理

v-model其实是个语法糖底层是基于【:value】和【@input】 封装

```
<input type="text" :value="msg" @input="msg = $event.target.value">

```

## 🌟 VUE2响应式原理（中级）

Vue2在初始化数据时，会使用Object.defineProperty语法对data中的所有属性进行数据劫持，如果属性发生变化就会通知进行更新操作

## 🌟 VUE2响应式原理（高级）

````
底层通过Object.defineProperty进行数据劫持，然后通过发布订阅通知视图更新。

或者

vue在初始化数据时，会使用Object.defineProperty重新定义data中所有属性，当页面使用对应属性时，首先会进行依赖收集（watcher，如果属性发生变化就会通知相关依赖进行更新操作（发布订阅。
并且底层针对于对象、数组做了特殊处理，对象类型多次递归，数组类型重写数组方法

````

## 🌟 VUE2响应式数据无法劫持原因、和解决方案

```
自己解决：递归全搞定
VUE解决：
1-对象递归
2-数组重写（因为深度监听需要递归到底，而数组相对数据很多，一次性计算量大  所以改用重写方式）
3-增加额外api
this.$forceUpdate()
this.$set(this.data数据, 要劫持得数组索引或对象键, 默认值)

```

## 🌟 $forceUpdate 原理

这个之前有大概看过源码

就是notify强制视图所有数据更新

## 🌟 $set 原理

1、他是vue原型上的一个方法

> https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L345
>
> https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L14

2、这个之前有大概看过源码

主要两大核心

1、通过defineReactive进行数据劫持

2、通过notify进行视图更新

> https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L201

## 🌟 $delete 原理

删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 `Vue` 不能检测到属性被删除的限制，但是你应该很少会使用它。

语法：this/Vue.$delete(target，propertyName/index)

1、他是vue原型上的一个方法

> https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L346
>
> https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L14

2、这个之前有大概看过源码

主要两大核心

1、通过delete 删除对象的属性

2、通过notify进行视图更新

> https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L236

## 🌟 Vue.set/delete 原理

https://github.com/vuejs/vue/blob/0603ff695d2f41286239298210113cbe2b209e28/src/core/global-api/index.js#L44

```
import { set } from '../observer/index'

...
Vue.set = set
...

```

```
import { set } from '../observer/index'

...
Vue.prototype.$set = set
...


```

都是从 ../observer/index 文件中导出的

区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。

## 🆕 响应式原理

为啥VUE3要选择proxy和reflect

```
- Object.defineProperty 拦截的是对象的属性，会改变原对象。 proxy 是拦截整个对象，通过 new 生成一个新对象，不会改变原对象。
- proxy 语法更强，拦截方式除了上面的 get 和 set ，还有 11 种，以前就6个
- proxy 特性更强，可以监听未定义的，针对于N层则get时判断递归添加proxy拦截即可

```

不用reflect可以吗

```
- 简单场景可以，复杂场景不行
- 举例：https://blog.csdn.net/qq_34629352/article/details/114210386  存在BUG
- 其次：用了更方便推荐结合用 例如 has、deleteProperty、defineProperty友好提示等

```

# 04-花式思想

## 💘 课件

04-Vue基础（花式思想：Class与Style绑定、计算属性、侦听器、过滤器、自定义指令、ref属性、混入）

## 🌛 Class与Style绑定工作有用过吗

```
:class="item.icon"
:style="{ width: item.payload ? item.payload.width : '100%' }"
:style="{ width: item.width || '70px' }"

1-后台管理系统菜单   v-bidn:style="{width: 模型数据}"
2-主题色切换
3-tab选项卡
4-其他

案例1：https://vant-contrib.gitee.io/vant/#/zh-CN/tab
源码1：https://unpkg.com/browse/vant@1.0.0/packages/tab/index.vue
案例3：https://element.eleme.io/#/zh-CN/component/tabs
源码3：https://unpkg.com/browse/element-ui@2.15.5/packages/tabs/src/tab-bar.vue
案例3：https://element.eleme.io/#/zh-CN/component/button
源码3：https://unpkg.com/browse/element-ui@2.15.5/packages/button/src/button.vue

```

## 🌟 计算属性和侦听器区别、使用场景

计算属性：计算属性有缓存、并且是响应式依赖缓存，调用不加小括号

侦听器：侦听器无缓存，侦听模型数据变化，不能调用

计算属性：

```
利用vuex辅助函数，结合计算属性去显示数据 项目中大量使用
分类树型数据格式、权限树型格式
等等复杂的逻辑，存在性能问题、或者避免重复调用存在性能问题的场景都可以使用计算属性。

```

侦听器

```
网站搜索
监控弹框显示二维码
模糊筛选、关键词筛选
日期筛选、下拉筛选
全选、全不选等
美团Admin项目中监控路由变化显示对应面包屑
等等

```

> - 相同点
>
> 1. 语法角度（ a 从思想上都是普通方法升级版 b 都可以写函数或对象
> 2. 研发角度：计算属性-减少冗余、缓存提升性能、侦听器-减少DOM操作 符合VUE响应式思想
>
> - 不同点
>
> 1. 从语法角度：调用时，计算属性调用不加小括号，侦听器不能调用
> 2. 从功能角度：计算属性有缓存、响应式依赖，侦听器没有缓存常用于搜索、监控数据变化、代替事件等

## 🌟 watch监控失效场景&解决方案

针对于对象类型的数据，需要加deep属性深度监听/侦听

## 🌟 watch两大属性应用场景

- deep是什么哪里用

> a-美团Admin项目中：监控路由变化，通过meta路由元信息重置面包屑🍞
>
> ```
> // watch: {
> //   // 针对于复杂类型的深度监听（注：深度监听场景）
> //   // params(newData) {
> //   //   console.log(newData);
> //   // },
> //   params: {
> //     deep: true,
> //     handler(newData) { // 也可以直接用日期组件的change事件
> //       console.log(newData);
> //  	   this.params.start_time = newData.date[0];
> //   		 this.params.end_time = newData.date[1];
> //     },
> //   },
> // },
>
> ```
>
> b-美团Admin项目中：给角色分配权限 重置树🌲型控件
>
> ```
> editAuth.vue
> // 获取所有权限  当前行数据变化获取最新的权限数据
> watch: {
> row: {
>  deep: true,
>  handler() {
>    getAuthsApi().then((res) => {
>    	this.authsData = res.data;
>    });
>  },
> },
> },
>
> ```
>
> C-美团Admin项目中：基于elementui二次封装的form编辑默认显示数据要监控row变化
>
> ```
> watch: { // qf-form封装的表单组件中，编辑传递的row当前行数据变化同步更改
> // row(newData) {
> //   console.log("watch", newData);
> // },
> row: {
>   handler(newData) {
>      if (!newData) return;
>      this.formData = newData;
>  },
>  immediate: true,
> },
> },
>
> ```

- immediate是什么哪里用

> a-美团Admin项目中：meat路由元信息【首次】重置面包屑🍞
>
> ```
> watch: { // 监控路由变化同步面包屑
> // $route(newData) {
> //   // console.log(newData);
> //   this.name1 = newData.meta.name1;
> //   this.name2 = newData.meta.name2;
> // },
> $route: {
>  handler(newData) {
>    this.name1 = newData.meta.name1;
>    this.name2 = newData.meta.name2;
>  },
> 	immediate: true,
> },
> },
>
>
> ```
>
> b-美团Admin项目中：基于elementui二次封装的form编辑默认显示数据要监控row变化
>
> ````
> watch: { // qf-form封装的表单组件中，编辑传递的row当前行数据变化同步更改
> // row(newData) {
> //   console.log("watch", newData);
> // },
> row: {
>   handler(newData) {
>      if (!newData) return;
>      this.formData = newData;
>  },
>  immediate: true,
> },
> },
>
> ````

## 🌟 谈谈你对过滤器的理解有没有用过

作用：项目用来过滤数据，便于维护

语法：Vue.filter()

场景：订单状态、商品状态、性别、支付状态、发货状态。

## 🌟 谈谈你对混入的理解有没有用过

作用：复用组件里面的逻辑层，减少冗余便于维护

语法：Vue.mixin({data,methods....})

场景：美团Admin项目中确认删除、接口操作后的提示重定向、jump重定向封装等等

场景：跳转封装this.$router.push 也是为了避免重复点击报错；也可以通过重置路由模块原型

# 05-组件编程

## 💘 课件

05-Vue基础（组件编程：组件、动态组件、组件通信传值、slot插槽）

## 🌟 为啥data要写函数里面返回对象

> 说明1
>
> ```
> 一个组件被复用多次，也就会创建多个实例，本质上都是基于同一个构造函数，如果data直接是对象，因为对象是引用类型，所以会影响到所有实例。
> 因此：为了保证组件不同的实例之间data不冲突，data必须是一个函数
>
> ```
>
> 或说法2
>
> ```
> 当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象
>
> ```
>
> 或说法3
>
> ```
> 因为组件是用来复用的，且 JS 里对象是引用关系，
> 如果组件中 data 是一个对象，那么这样作用域没有隔离，
> 子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，
> 那么每个实例可以维护一份被返回对象的独立的拷贝，
> 组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，
> 是不会被复用的，因此不存在引用对象的问题。
>
>
>
> function Component() {}
> Component.prototype.data = {
> name: "jack",
> age: 22,
> };
> var componentA = new Component();
> var componentB = new Component();
> componentA.data.age = 55;
> // componentA 和 componentB data之间指向了同一个内存地址，
> // 相互污染
> console.log(componentA, componentB);
>
>
>
> function Component() {
> this.data = this.data();
> }
> Component.prototype.data = function () {
> return {
>  name: "jack",
>  age: 22,
> };
> };
> var componentA = new Component();
> var componentB = new Component();
> componentA.data.age = 55; // 互补影响
> console.log(componentA, componentB);
>
>
> ps.
> let a = {}
> let b = {}   互补影响
> ----------
> let a = {}
> let b = a    相互影响（一个对象赋值给另一个对象  才会相互影响
>
> ```
>
>

## 🌛谈谈你对单向数据流的理解

单向数据流指在组件化思想，开发的项目中，数据由根或者父组件传递给子组件，禁止🈲子组件中直接更改，而是由父更改后重新传递给子数据使用

```
// 在vue中 只能父数据传递给子 父修改后会自动同步到子
// 不允许子修改父
// 生活中：你妈给你多少钱 就用多少，不允许你直接去拿 否则长大了完犊子
// 代码中：父给你就用，你自己直接改 容易后期搞懵逼谁串改了数据

```

## 🌟 如何实现组件通信？

常用：父传子 props、子传父$emit、兄弟 eventBus

常用：状态管理工具 vuex

常用：slot插槽
概率：通过组件实例 ref获取、$parent获取、$root获取、$children获取
概率：v-model
了解：利用provide、inject

### 父传子

```
1、在子组件的组件标签上，动态的绑定一个属性，值就是想要传递的值
2、在子组件中，通过props属性进行接收，子组件标签绑定的属性名

```

### 子传父

```
1、在调用子组件的标签上，通过v-on注册一个事件，然后事件的处理函数，写到父组件methods中
2、子加载完毕，或者是触发事件后，通过$emit通知父

```

### 兄弟组件传参

```
在Vue中可以使用 EventBus【const bus = new Vue()】来作为沟通桥梁的概念
EventBus.$emit('自定义事件名'，要传送的数据)
EventBus.$on("事件名"，callback)

```

## 🌟 事件.native作用

概念：直接在组件上绑定原生事件

举例：使用elemenui、vantui封装的弹框、input等组件，需要使用官方原生事件

## 🌟 在组件上写原生事件失效解决方案

> 方法1：通过自定义事件重写原生事件
>
> 方法2：加.native修饰符

## 🌟 在组件上使用v-model原理

工作极少

但是笔试可能需要手写

```
<组件名 v-model="data中的键"></组件名>
<组件名 :value="data中的键" @input="data => data中的键 = data"></组件名>

```

## 🌛 修饰符.sync原理

```
<组件名 v-bind:属性名.sync="data中的键"></组件名>
<组件名 v-bind:属性名="data中的键"  @update:必须一样的属性名="data => data中的键 = data"></组件名>

```

# 06-剩余知识：生命周期、keep-alive等等

## 💘 课件

06-Vue基础（剩余知识：虚拟DOM、浏览器运行机制、回流重绘、生命周期、keep-alive、transition过渡

## 🌟 说出浏览器运行机制

浏览器主进程，负责创建和销毁tab进程、负责交互前进后退、负责网页文件下载等
渲染进程：每个tab对应一个渲染进程，下面有GUI渲染线程、JS引擎线程、事件线程、定时器线程、异步请求线程
GPU进程：负责3D图绘制
第三方插件进程：负责第三方插件处理，例如跨域、广告拦截插件等

## 🌟 说出浏览器输入网址干了啥

```
浏览器输入网址回车
去DNS服务器找网址对应的IP地址
根据IP地址加端口访问服务器软件
服务器返回数据
浏览器通过renderer是渲染进程处理，
其中GUI线程主要负责页面布局，解析HTML、CSS构建DOM树、CSS规则树、然后结合成渲染树、最终绘制显示

```

## 🌛 说出JS为什么是单线程

> ### 先看一个比喻
>
> 进程就是一个公司，每个公司都有自己的资源可以调度；公司之间是相互独立的；而线程就是公司中的每个员工(你，我，他)，多个员工一起合作，完成任务，公司可以有一名员工或多个，员工之间共享公司的空间
>
> ### 什么是进程？
>
> 进程：是cpu分配资源的最小单位；（是能拥有资源和独立运行的最小单位）
>
> ### 什么是线程？
>
> 线程：是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
>
> #### 浏览器是多进程的
>
> 放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。
>
> ### 大家都在说js是单线程的，但是为什么要设计成单线程？
>
> 这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变.
>
> #### 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

## 🌛 说出JS是单线程 为什么不存在执行效率问题

JS是单线程执行程序代码，形成一个执行栈，挨个处理；

但是遇到特别耗费时间的代码 ，例如异步请求，事件等，

不会堵塞等待执行，而是交给浏览器其他线程处理后，再丢到执行栈中处理，从而保证还行效率

## 🌟 谈谈你对回流重绘的理解

回流/重排：页面布局流发生改变就叫做回流，例如：width、height、border、top等
重绘：重绘元素自身的样式发生改变但是不会影响布局流，例如：color、background、box-shadow等

## 🌟 哪些属性导致回流、哪些属性导致重绘

例如：width、height、border、top等
例如：color、background、box-shadow等

```
1、添加或删除可见的DOM元素
2、元素的位置发生变化
3、元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
4、内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
5、页面一开始渲染的时候（这肯定避免不了）
6、浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

而重绘是指在布局不变得情况下，比如background-color,或者改动一下字体颜色的color等。

```

## 🌟 如何避免或减少回流重绘

> **JavaScript优化法**
>
> ```
> （1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
> （2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中，也就是虚拟DOM
> （3）避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
>
> ```
>
>
>
> **CSS优化法**
>
> ```
> （1）使用 transform 替代 top
> （2）使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局
> （3）避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。
> （4）尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
> （5）避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
> （6）将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。
> （7）避免使用CSS表达式，可能会引发回流。
> （8）将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。
> （9）CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。
>
> ```

## 🌟 谈谈你对虚拟DOM的理解

通过js对象来描述真实的DOM，从而减少回流重绘





> 减少了同一时间内的页面多处内容修改所触发的浏览器reflow和repaint的次数，可能把多个不同的DOM操作集中减少到了几次甚至一次，优化了触发浏览器reflow和repaint的次数。。

## 🌟 说出VUE有哪些生命周期并说出应用场景

before开头的实际不用

非before开头

````
created   异步请求
mounted   异步请求、DOM操作（swiper、echarts、聊天默认滚到底部）
updated   监控数据变化进一步DOM操作，例如聊天窗口到底部、订单可视化图表重置等等
destroyed 清理非vue资源防止内存泄露，例如登陆倒计时定时器

````

剩余

```
activated	   组件被keep-alive缓存后，执行场景场景数据，例如添加后列表更新最新数据
deactivated  组件被keep-alive缓存后代替destroyed工作
errorCaptured 当页面发生错误是优雅降级，显示友好提示页面，react框架提示就是参考这一做法

```

> tips
>
> 优雅降级(`graceful degradation`)：一开始就构建站点的完整功能，然后针对浏览器测试和修复。
>
> ive enhancement`)：一开始只构建站点的最少特性，然后不断针对各浏览器追加功能。



渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。

优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

## 🌟 created里面可以操作DOM吗

通过ref不行，原生JS可以，因为该钩子函数触发还没有编译（不推荐

非要通过ref操作，可以写this.$nextTick来实现

```
<div id="root">
  <button ref="btn">a</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  const vm = new Vue({
    el: "#root",
    data: {},
    created() {
      let btnObj = document.querySelector("button");
      console.log("js可以", btnObj);
      console.log("ref不行🚫", this.$refs.btn);

      this.$nextTick(() => {
        console.log("ref可以", this.$refs.btn);
      });
    },
  });
</script>

```

## 🌛 watch与created() 哪个先执行？

watch 中的 immediate 会让监听在初始值声明的时候去执行监听计算，否则就是 created 先执行

````
<div id="root">
  <h1>{{msg}}</h1>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  const vm = new Vue({
    el: "#root",
    data: {
      msg: "hello",
    },
    created() {
      console.log("后created");
    },
    watch: {
      msg: {
        handler() {
          console.log("先watch");
        },
        immediate: true,
      },
    },
  });
</script>


````

## 🌛数据可视化 echarts

在项目中的使用细节，数据的使用，修改，销毁？

细节1：首次实例化渲染，mounted中注意dom是否挂载，特别是操作子组件

细节2：重置echarts数据，如果页面没有遍历显示数据明细，无法在updated钩子函数监控

> 解决：watch或者更新后直接调用methods方法

细节3：重置echarts数据，得重新实例化才能显示最新数据

细节4：离开组件手动关闭连接 ws.close()  （注：如果定时器写的要清除定时器

## 🌟 谈谈你对keep-alive的理解，并说出应用场景

vue中内置组件，主要将组件相关数据缓存到内存中，避免重复挂载卸载产生的性能开销

场景：后台管理系统环境数据、移动端长列表、tab选项卡等

周边问题

> 1-缓存组件使用哪个属性？
>
> ```
> :include、:exclude、:max
>
> ```
>
> 2-此时多的哪两个钩子函数？
>
> ```
> activated 、deactivated
>
> ```
>
> 3-页面加载刷新的时候，被缓存的组件，会执行其中的方法吗？
>
> ```
> 刷新就相当于首次打开  所以created、activated又重新出发
>
> ```

## 🌟 谈谈你对$nextTick的理解，并说出应用场景

理解：vue中用来确保，在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

场景：对话框放登录二维码，放表单选项获取数据、获取焦点，点击事件修改对话框状态后开始加载DOM，为确保能获取并操作DOM使用$nextTick包起来。

语法:

```
// 修改数据
vm.msg = 'Hello'
// DOM 还没有更新
Vue.nextTick(function () {
  // DOM 更新了
})

// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
Vue.nextTick()
  .then(function () {
    // DOM 更新了
  })

```

## 🌟 说出$nextTick原理

> Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的)
> 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。



Vue底层监控的数据更新会开启一个队列进行优化处理，然后在下一个的事件循环中去触发nextTick的callback执行，也就是会把nextTick的callback依次尝试放到用原生的 Promise.then、MutationObserver 和 setImmediate、setTimeout中，底层核心代码大致思路如下

```
1. 把回调函数放入callbacks等待执行
2. 将执行函数放到微任务或者宏任务中
3. 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调

```

https://github.com/vuejs/vue/blob/dev/src/core/global-api/index.js#L46

https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L87

```
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => { // 将拿到的回调函数存放到数组中
    if (cb) {
      try { // 错误捕获
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) { // 如果当前没有在pending的时候，就会执行timeFunc
    pending = true
    timerFunc() // 多次执行nextTick只会执行一次，timerFunc就是一个异步方法
  }
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
//

```

https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L33

```
const callbacks = []
let pending = false

function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}


let timerFunc

//判断1：是否原生支持Promise
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
	//判断2：是否原生支持MutationObserver
  isNative(MutationObserver) ||
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  //判断3：是否原生支持setImmediate
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  //判断4：上面都不行，直接用setTimeout
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}

```

# 07-项目准备：路由相关

## 💘 课件

07-Vue高级（项目准备：路由、重定向、模式、参数、动态路由匹配、编程式导航、嵌套路由、导航守卫、动态路由规则addRoutes）

## 🌛 路由-对象里面的键

{

​ path,

​ component,

​ name,

​ redirect,

​ alias

​ children,

​ components

​ meta

....

}

## 🌟 路由-你说下vue路由模式有几种？

<https://router.vuejs.org/zh/api/#mode>

常用路由模式有2个，分别为hash和history 直接修改路 由构造函数加个mode键即可

准确说有3个，hash/history用于客户端，abstract用户服务端

## 🌟 路由-你说下vue路由原理？

首先vue路由是基于SPA单页面应用思想去开发的

利用BOM API 来使用

hash模式 通过 BOM location对象的hash属性来改变路由 window.onhashchange

history模式 通过BOM history对象的pushState方法来改变路由 window.onpopstate

## 🌟 路由-history有什么问题，如何解决？

刷新无法加载网页问题

可以通过服务器配置来解决

## 🌟 路由-那你说下什么是单页面应用SPA优缺点，如何选择

SPA优点：减少HTTP请求、加载响应数据、提高用户体验度，方便增加动画
SPA缺点：首屏加载过慢、不利于SEO优化（就是百度可以搜到你）

如何选择
根据项目需求，老板没有明确说就不管，
但是老板说需要seo优化则通过：Vue.js 服务器端渲染（nuxt.js）



> tips
>
> 1-为什么单页面(SPA)网站无法被seo？：https://www.zhihu.com/question/416192007/answer/1424413130
>
> 2-多页面应用(MPA)也就是二升三美团PC项目也是不利于seo优化，最终是否利于seo主要还是看页面数据是直接和html一起返回的、还是要重新发送ajax请求的。
>
> 3-vue中想利于seo则通过nuxt.js技术，react则通过next.js

## 🌟 路由-动态路由匹配

问题：同一个组件仅仅修改参数created不触发

详情：改路由参数获取最新的 ，就得使用动态路由匹配语法

语法：watch 、或 组件内导航守卫beforeRouteUpdate

## 🌟 路由-谈谈你对编程式导航的理解

作用：就是利用js跳转网页

留心：声明式就是用a标签跳转

场景：登陆、添加按钮、删除按钮等

语法

```
this.$router.push( { path:'/路径', query: {参数名:值} } )
this.$router.push( { name:'名称', params: {参数名:值} } )

获取：this.$route.query/params.参数名

```

## 🌟 路由-说出嵌套路由&命名视图的场景

嵌套路由

```
概念：一个路由，显示多个组件，并且有父子关系所以通过children来定义
语法：子路由通过children来定义，然后父的组件内容通过router-view来显示匹配的子组件
场景：后台管理系统经典两栏布局 点击左侧菜单，右侧显示子组件内容

```

命名视图

```
概念：一个路由，显示多个组件，并且有兄弟关系所以component改为components
语法：定义路由把component改为components，然后视图给router-view 加name属性
场景：移动端navBar、tabBar

```

## 🌟 路由-全局导航守卫登陆鉴权

作用；没登陆不可以访问会员中心、后台首页

语法：router.beforeEach 判断h5 next

```
// 全局前置守卫
// 导航守卫：导航/地址栏门卫，监控路由变化
router.beforeEach((to, from, next) => {
  // ...
  // to 存放新的路由数据
  // from 存放旧的路由数据
  // next()    写- 允许后续代码执行，可以看到组件内容
  // next()   不写- 阻止后续代码执行，因此组件不渲染看不到内容
  // next({path: '/login'}) 跳转到login页面

  // console.log(to);
  // 检查当前访问的路径
  // 在数组中就直接next 不用检查是否登录
  // 白名单
  if (["/login", "/404"].includes(to.path)) {
    next();
  } else {
    // 上述白名单直接忽略不用判断
    // 但是其他得判断
    let token = localStorage.getItem("token");
    if (token) {
      next();
    } else {
      next({ path: "/login" });
    }
  }

```

## 🌟 路由-导航守卫种类&作用

种类：全局、路由、组件

> ```
> 全局：beforeEach				 登录状态、网页加载进度条
> 全局：beforeResolve	    不用（路由、组件守卫被解析也就是被调用后）
> 全局：afterEach			    关闭网页加载进度条 NProgress
> 路由：beforeEnter		    不用
> 组件：beforeRouteEnter   组件被创建前（注：不能用this）
> 组件：beforeRouteUpdate   动态路由匹配/动态获取路由参数
> 组件：beforeRouteLeave   未保存离开组件/清除定时器/切换组件保存数据等
>
> ```
>
>

全局

> **全局前置守卫** beforeEach
>
> ````
> 场景1：登录验证，判断用户是否登录，登录-next()，没登录-重定向到登录页 next({path:'/login'})
> 场景2：显示网页加载进度条
>
>
> // 导航守卫（监控路由变化）
> // to 路由对象（新页面路由对象  to.path 可以获取当前新页面路由路径
> // form 路由对象（旧页面路由对象  form.path 可以获取当前旧页面路由路径
> // next 函数  可以控制页面正常访问或者重定向
> import store from "@/store";
> import router from "@/router";
> import NProgress from "nprogress";
> import "nprogress/nprogress.css";
>
> const whiteList = ["/login", "/404", "/login/sms", "/login/token"];
>
> router.beforeEach((to, from, next) => {
> NProgress.start();
> // ...
> // 1 判断你访问的是什么页面
> if (whiteList.indexOf(to.path) != -1) {
>  next();
> } else {
>  // 登录相关的页面、404 直接next
>  // 其他 判断token是否存在
>  // let token = this.$store.state.login.token
>  let token = store.state.login.token;
>  // - 存在 next({})
>  // - 不存在 next({path: '/login'})
>  if (token) {
>    if (store.state.auths.menus.length <= 0) {
>      console.log("重新获取权限菜单");
>      store.dispatch("auths/FETCH_MENUS");
>    }
>    next();
>  } else {
>    next({ path: "/login" });
>  }
> }
> });
>
> router.afterEach(() => {
> NProgress.done();
> });
>
>
> ````
>
> **全局解析守卫**beforeResolve 2.5.0+
>
> ```
> 场景：不用
> 触发：路由、组件守卫被解析也就是被调用后
>
> ```
>
> **全局后置钩子**afterEach
>
> ```
> 场景：关闭网页加载进度条 NProgress
> 触发：最后、特色没有next不会改变导航本身：
>
>
> router.afterEach(() => {
> NProgress.done();
> });
>
> ```

路由

> ```
> {
> 	path,
> 	component,
> 	...
> 	beforeEnter: (to, from, next) => {
> 	// ...
> }
> }
>
> ```
>
>

组件

> ```
> Vue.component(组件名, {
> 	beforeRouteEnter    组件被创建前（注：不能用this）
> 	beforeRouteUpdate (2.2 新增)   动态路由匹配/动态获取路由参数
> 	beforeRouteLeave   未保存离开组件/清除定时器/切换组件保存数据等
> })
>
> beforeRouteLeave (to, from, next) {
> // 禁止用户在还未保存修改前突然离开
> const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
> if (answer) {
> next()
> } else {
> next(false)
> }
> }
> 或
> beforeRouteLeave (to, from, next) {
> window.clearInterval(this.timer) //清楚定时器
> next()
> }
> 或
> beforeRouteLeave (to, from, next) {
> // 当用户需要关闭页面时, 可以将公用的信息保存到session或Vuex中
> localStorage.setItem(name, content); //保存到localStorage中
> next()
> }
>
> ```

## 🌛 路由-导航守卫执行顺序

```
导航被触发。
在失活的组件里调用 beforeRouteLeave 守卫。
调用全局的 beforeEach 守卫。
在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
在路由配置里调用 beforeEnter。
解析异步路由组件。
在被激活的组件里调用 beforeRouteEnter。
调用全局的 beforeResolve 守卫 (2.5+)。
导航被确认。
调用全局的 afterEach 钩子。
触发 DOM 更新。
调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

```

## 🌟 路由-动态路由如何实现

面试提问

````
如何实现权限控制
如何实现菜单权限
如何实现动态路由
如何动态添加路由规则
项目是前端路由还是后端路由

````

实战项目回答

````

````

作用&语法

> 作用：不同角色，权限菜单看到的不一样
>
> 步骤1：页面菜单导航根据接口数据渲染
>
> 步骤2：路由不能全部写死，利用addRoutes或addRoute动态添加路由规则

## 🌟 路由-元信息有啥用

meta 存放面包屑、也可以加标识控制是否缓存组件

实现1：页面菜单导航根据接口数据渲染

实现2：路由不能全部写死，利用addRoutes或addRoute动态添加路由规则

```
router.addRoute("admin", {
  path: twoMenu.url,
  component: () => import("@/views/" + twoMenu.component),
  meta: {
    name1: twoMenu.auth_pname,
    name2: twoMenu.auth_name,
    keep_alive: twoMenu.keep_alive,
  },
});

```

## 🌛 路由-过渡特效场景

项目中会用到

```
<transition class-enter-class="animated 类名">
  <router-view></router-view>
</transition>

```

# 08-项目准备：脚手架相关

## 💘 课件

08-Vue高级（项目准备：脚手架、ToDoList案例、Vue.config.js配置、实战组件封装）

## 🌟 说出框架中做了哪些配置

别名

跨域（最终上线还得后端或运维处理

等

## 🌟 说出跨域的解决方案

常用的

谷歌命令

谷歌插件

JSONP

http-proxymiddleware

等等

## 🌟 说出Vue.use原理

Vue.use的主要作用就是：全局注册，

然后底层源码大致做了两件事

```
1 检查传递的插件有没有重复注册
2 判断plugin.install是不是函数 或 plugin 是不是函数  然后分别用apply调用让函数执行  注册，

Vue.component(组件名, 单文件组件)

```

源码 https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js

````
export function initUse (Vue: GlobalAPI) {
  // 接受一个plugin参数，限制为 Function | Object两种类型
  Vue.use = function (plugin: Function | Object) {
    // _installedPlugins 存储所有注册过的 plugin
    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
    // 保存注册组件的数组，不存在则创建，存在则直接返回，不允许重复注册
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    // 将传入的参数转换成数组
    const args = toArray(arguments, 1)
    // 将Vue对象拼接到数组头部
    args.unshift(this)
    // 如果提供了 install 方法，则直接调用
    if (typeof plugin.install === 'function') {
      // 如果组件是对象，且提供install方法，调用install方法将参数数组传入，改变`this`指针为该组件
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      // 否则直接执行
      plugin.apply(null, args)
    }
    // 将plugin存储到  installedPlugins，表示y已经注册过
    installedPlugins.push(plugin)
    return this
  }
}


````

```
/**
 * Convert an Array-like object to a real Array.
 */
export function toArray (list: any, start?: number): Array<any> {
  start = start || 0
  let i = list.length - start
  const ret: Array<any> = new Array(i)
  while (i--) {
    ret[i] = list[i + start]
  }
  return ret
}

```

## 🌛 说出UI组件库/UI框架原理

首选通过vue单页面应用定义好公共组件

然后通过Vue.use批量注册

接着打包

> ```
> "scripts": {
>  "serve": "vue-cli-service serve",
>  "build": "vue-cli-service build",
>  "ui": "vue-cli-service build --target lib --name qf-ui --dest qfui ./src/qfui/index.js"
> },
>
> ```

最后按照node包发布就可以使用

# 09-项目准备：状态管理vuex相关

## 💘 课件

09-Vue高级（项目准备：VUEX单库、VUEX数据持久化b、VUEX单库模块化、VUEX框架模块化b）

## 🌟 说出vuex有哪些键

```
state、getters、mutations、actions、plugins、modules

```

## 🌟 说出vuex工作流

```
state存放数据、
getters过滤
mutations更新
actions异步请求

```

## 🌟 说出vuex数据持久化

vuex缺陷：刷新数据会丢失

解决方法：H5存储

​ 第三方模块

# 10-项目准备：UI组件库/框架

## 💘 课件

10-Vue高级（项目准备：UI组件库ElemenUI、IView、AntdV、Vant、Mint等、自研UI组件库）

## 无

# 11-项目准备：异步请求

## 💘 课件

11-Vue基础（项目准备：axios、fetch数据请求

## 🌟 【接口】谈谈你对HTTP理解

```
超文本传输协议、规定客户端和服务端如何通信，

他是是请求行，响应行，请求头，响应头，请求体，响应体组成，
之前我做项目的回收 请求行你们主要查看请求地址、请求状态、请求方式、请求体头里面主要放cookie、token、content-type等，请求体主要看参数有没有传递给后端、响应体后端返回的数据进行项目调试。

```

## 🌟 【接口】谈谈你对状态码的理解

```
2xx  200成功 201成功并创建新资源
3xx  301永久重定向 302临时重定向 304浏览器缓存
4xx  400参数有误 401密码错误 403无权访问 404文件不存在 405请求方式有误
5xx  500服务器错误

```

## 🌟 【接口】post、get区别

```
安全角度   post对象安全 get地址栏 后期可以通过历史记录查看登陆密码
数据角度   get地址栏 不同浏览器地址栏长度限制   post后端规定 2M 8M

```

## 🌟 【接口】xhr、fetch区别

```
xhr、fetch

相同点：1-都可以发送异步请求、2-都是ECMA定义的
不同点：前者异步回调地狱，后者promise

```

> 其他了解
>
> ```
> 最初ajax（XMLHttpRequest ECMA组织）   瑕疵：1-语法麻烦太多，2-异步回调地狱，3-语法有兼容性问题
> 后台jq（第三方作者）
> 	明确：JQ里面的$.ajax/get/post是基于XMLHttpRequest封装的  function + ajax + callback
> 	好处：语法更简单、解决很多兼容性问题
> 	瑕疵：异步回调地狱还在
>
> 	解决：通过promise技术
>
> 最后fetch（ECMA组织）  ：结合promise技术而生，代替传统xhr
>
> ```

## 🌟 【接口】fetch、axios区别

```
相同点：1 都可以发送异步请求，2 都是promise
不同点：1 fetch官方、axios社区，2 axios更强并发、拦截器等

```

## 🌟 【接口】axios之前有没有封装过

````
- 封装axios导出request实例对象（timeout、baseURL、headers content-type、.env
- 请求拦截器（开启Loading、token、CancelToken
- 响应拦截器-成功（关闭Loading、res.data.data过滤 、 接口权限、TOKEN过期
- 响应拦截器-失败（关闭Loading、timeout处理 、404、canceled、邮件报警捕捉前端异常

````

## 🌟 【接口】axios原理

基于xmlhttprequest构造函数、和node中的http模块封装实现，动态判断浏览器环境、还是服务端环境

去选择对应语法返回promise对象

## 🌟 【接口】跨域如何解决

常用的

谷歌命令

谷歌插件

前端代理 http-proxy-middleware

JSONp

留心：不管前端咋操作最终上线都得后端或者服务器配置

# 12-项目开发：Vue千锋🤝美团项目

## 🌟 项目开发中有没有封装过组件

有

或者用语言：开发过

## 🌟 项目中封装了哪些组件

自己随意组织语言，重点体现页面组件， 毕竟不是很大，很复杂的项目你想不了多少全局公共组件；

因此可以回答：

例如编辑用户、分配角色，分配权限、门店创建、分类编辑等都有封装提取页面组件，从而便于后期维护，

还有公共的table、form、page组件等

## 🌟 组件如何封装的

页面组件：首先在页面中完成功能，然后再views/模块名/components中定义单文件组件，然后导入使用，从而让组件更便于后期维护

> 概念：将组件中不同逻辑的代码提取封装，便于后期维护



公共组件：首先在src/components定义form公共组件，然后全局注册导入使用，最终根据需求利用props接受参数&创建自定义事件

## 🌟 样式相关

- 题目1：如何防止样式的污染？

```
scoped

```

- 题目2：scoped解决样式污染原理

> 说明：vue在编译的时候通过在DOM元素以及css样式上加上唯一标记，实现样式私有化，不污染全局样式。
>
> 举例：
>
> ```
> <div class="my-class"></div>
> 编译为
> <div class="my-class" data-v-56e7f952></div>
> 对应的样式.my-class编译为
> .my-class[data-v-56e7f952]
>
> ```
>
> 原理：利用前端自动化构建工具webpack结合PostCSS模块编译实现css模块化
>
> https://www.postcss.com.cn/

- 题目3：项目中开启样式私有化后，无法修改子组件例如elementui、antdv如何解决

```
通过深度作用选择器，你可以使用 >>> 操作符；有些像 Sass 之类的预处理器无法正确解析 >>>。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 >>> 的别名，同样可以正常工作。

```

https://vue-loader.vuejs.org/zh/guide/scoped-css.html#%E6%B7%B1%E5%BA%A6%E4%BD%9C%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8

## 🌟 用户角色权限三者是如何关联的

首先在权限管理可以添加删除权限，实现后端路由

接着可以添加删除角色，然后给角色分配权限

最后在用户管理给用户分配角色，

后期不同用户登录就可以看到不同点权限菜单/导航

## 🌟 说一下登录如何实现的

1、通过elementui布局 表单验证

2、给登录绑定点击事件，...

3、然后通过vuex辅助函数 调用 actions 去请求接口

4、失败弹框提示，成功将token、uname、roleName存储vuex中，然后提示登录成功&&重定向

```
1 vuex周边问题 比如数据持久化、比如有哪些键
2 axios周边问题
3 token周边问题（过期问题

```

## 🌟 如何判断用户是否登录

## 🌟 登录是如何鉴权的

通过全局导航守卫判断，白名单直接next、非白名单判断h5或vuex中是否存在 不存在重定向到 登录页即可

## 🌟 说一下token过期机制

纯前端处理

```
1 登录既要存token  又要额外存一个时间
2 axios请求拦截器里面  判断是否过期 提示token过期，然后就重定向到登录页

```

前后端结合处理

```
1 登录就存token
2 请求拦截器每次请求携带token
3 响应拦截器判断是否过期  提示token过期，过期就重定向登录页

```

## 🌟 项目中是前端路由还是后端路由

## 🌟 权限菜单如何实现的

后端路由

追问：后端路由如何实现的？

回答：几个关键词 请求接口、addRoute、菜单还的遍历搞出来、vuex

```
1、首先通过vuex定义actions获取当前用户的权限数据，然后触发mutations、保存到state中、并且通过addRoute添加动态路由
2、在导航守卫中判断store中的权限数据是否存在，存在next不存在全局导航守卫beforeEach触发action获取
3、后台首页layout下面的menu中通过辅助函数获取遍历显示

```

其他备注：一般token有效期7200s 也就是2小时 具体看公司

## 🌟 ....

## 🌟 说一下Diff算法

算法规则

```
1 步骤一：用JS对象模拟DOM树
2 步骤二：比较两棵虚拟DOM树的差异（切记切记切记：一层一层比）
3 步骤三：把差异应用到真正的DOM树上
4 步骤四：在页面展示

虚拟DOM介绍：https://www.jianshu.com/p/616999666920
如何实现一个Virtual DOM 算法：https://github.com/livoras/blog/issues/13
深入理解Diff算法：https://blog.csdn.net/lunahaijiao/article/details/86741739

```

```
<div id="root">
    <div v-for="item in todos">
        <input type="checkbox" name="" id="">
        {{item.title}}
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
const vm = new Vue({
    el: "#root",
    data: {
        todos: [
            {id:1, title:'吃饭'},
            {id:2, title:'睡觉'},
            {id:3, title:'挤痘痘'},
        ]
    }
})
</script>

步骤1：通过浏览器运行 ，给第二个checkbox打钩
步骤2：在控制台 vm.todos.splice(1,1)

```

什么是虚拟DOM：就是使用javascript的对象来描述了DOM结构

为什么要虚拟DOM：提升性能（因为回流、重绘 浏览器工作机制）

如何更新DOM数据：通过diff算法（同层比较）

```
1 步骤一：用JS对象模拟DOM树
2 步骤二：比较两棵虚拟DOM树的差异(注：后期如果写写遍历 加上:key 提升性能的)
3 步骤三：把差异应用到真正的DOM树上

```

切记：当遍历数据的时候要写key 提升性能、也是避免BUG

​

## 🌟 项目做了哪些优化

> ## ● 交互角度
>
> animate.css
>
> vue-lazyload
>
> nprogress
>
> loading
>
> preventReClick
>
> 等
>
>
>
> ## ● 代码角度
>
> 混入
>
> 过滤器
>
> 页面组件提取封装
>
> 公共组件提取封装
>
> axios封装
>
> 全局配置文件 process.env
>
> 等等
>
>
>
> ## ● 性能角度
>
> 【先把nginx服务器好好品】强制缓存、协商缓存：304 浏览器默认状态码、expires 缓存（学cookie不重要但是单词重要）
>
> 【先把nginx服务器好好品】gzip压缩
>
> 路由/组件懒加载
>
> 开发preload预加载
>
> 关闭prefetch预加载 （预加载的一种 准确说叫预提取
>
> ```
> https://blog.csdn.net/vivo_tech/article/details/109485871
>
> ```
>
> keep-alive组件缓存
>
> CDN优化第三方库
>
> UI框架按需加载
>
> 图片压缩
>
> 等等

# ■ 周边

## 🌟 【事件循环】谈谈你对Event Loop的理解

`Event Loop`即事件循环，

是指浏览器或`Node`的一种确保javaScript单线程运行时不会阻塞的一种机制，

也就是我们经常使用**异步**的原理。

种类：浏览器的Event Loop、Node.js中的Event Loop

## 🌟 【事件循环】谈谈你对浏览器的Event Loop理解

浏览器输入网址服务器响应数据后，

浏览器会通过render进程开始解析工作

GUI线程负责页面渲染

JS引擎线程负责执行JS代码

遇到异步代码会交给其他线程处理，然后放到队列中，

事件循环主要是从队列中取出代码放到执行栈中交给js引擎线程处理

## 🌛【事件循环】谈谈你对Node.js中的Event Loop理解

> libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。

```
timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
idle, prepare 阶段：仅node内部使用
poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里（轮训阶段）
check 阶段：执行 setImmediate() 的回调
close callbacks 阶段：执行 socket 的 close 事件回调

```

## 🌟 【事件循环】说出宏任务、微任务各有哪些

> 单词含义：I input 输入、 O output 输出
>
> 用户角度IO操作：鼠标键盘-是计算机输入信息，显示器-是输出设备
>
> 电脑角度IO操作：CPU、内存与其他设备之间数据转移过程就是IO操作，例如数据从磁盘读到内存，或者内存写到磁盘
>
> 编程角度IO操作：进程读取数据操作

- 宏任务：

```
整体代码（script）
定时器（setTimeout、setInterval）
I/O操作（DOM事件、AJAX异步请求）

setImmediate（node环境）
requestAnimationFrame（浏览器环境）

```

- 微任务

```
Promise.then catch finally
async/await（底层还是promise）
process.nextTick（node环境）
MutationObserver（浏览器环境）

```

## 🌟 【事件循环】说出先执行宏任务还是微任务

算整体代码script：1宏n微

不算整体代码script：先n微，再1宏 ->  n微，再1宏

## 🌟 【事件循环】浏览器和node中event loop区别

浏览器：一个宏走完清空所有微任务

node：一个阶段走完 再清空所有微

# 小程序

#### 小程序接口必须是https 你写的项目中是谁操作的

```
这个配置是公司后端/运维配置的，但是我个人对编程还是比较喜欢研究的 然后呢我就自己谷歌了一把发现就是去腾讯、阿里云申请证书，然后修改nginx配置就行。我当时用的是免费版，收费版没试过。
```

#### 小程序微信登录时怎么实现的

```
首先通过wx.login和wx.reqeuset获取openid  然后根据API去获取用户的昵称和头像
```

#### 小程序项目你做过哪些优化

```
静态资源优化:
图片懒加载
七牛云对象存储
cdn加速
expires     之前给大家发的nginx课件里面有
gzip        之前给大家发的nginx课件里面有
后端接口优化:
接口开发规范restful api
接口安全（https）
接口性能（多台数据库、缓存服务器redis存内存等）
```

#### 咱们项目开发完毕发小超过2M 如果解决

```
静态资源 咱们可以分离项目 放到CDN服务器上
太大了可以讲一个小程序变成2个小程序  这样就是4M
然后通过声明式导航、编程式导航，点击直接跳转到另一个小程序即可。
```

# React

#### react如何实现双向绑定

```
在React当中，有个onChange属性，可以给input绑定事件，当input框里的值发生变化时会触发调用方法，这个方法会合并data到this.state,并重新渲染组件。
```

#### 高阶组件是什么 什么情况下有用到

```
如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。
什么时候使用：页面复用,组件渲染性能追踪，权限控制。
```

#### react生命周期

```
React组件的生命周期可以分为挂载、渲染和卸载这几个阶段，当渲染后的组件需要更新的时候，我们会重新去渲染组件，直到卸载。
因此，我们可以把React生命周期分为两类：
1 当组件在挂载或卸载时
2 当组件接收新的数据时，即组件更新时

componentWillMount  在渲染前调用
componentDidMount  在第一次渲染后调用
componentWillReceiveProps  在组件接受一个新的prop时调用，这个方法在第一次渲染的时候不会被调用。
shouldComponentUpdate  返回一个布尔值，在组件接受到新的props或是state时被调用。在初始化时或是使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。
componentWillUpdate 在组件接受到新的props或是state但还没有render时被调用。在初始化时不会被调用。
componentDidUpdate  在组件完成更新后立即调用。在初始化时不会被调用
componentWillUnmount  在组件从DOM中移除的时候立即被调用
```

#### react做过哪些优化

```
1 减少不必要的props引起的重绘
2 减少不必要state引起的重绘
3 长列表优化
```

#### redux 流程

```
1.View在redux中会派发action方法;
2.action通过store的dispatch方法会派发给store;
3.store接收action，连同之前的state，一起传递给reducer；
4.reducer返回新的数据给store；
5.store去改变自己的state。
```

#### Redux 数据流动 有什么组件 redux中connect介绍一下   connect的底层是什么

```
connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产Component的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect，这样就生产出一个经过包裹的Connect组件。
```

#### React的路由 项目中用到什么路由 介绍一下

```
1 两种常用的路由：HashRouter和BrowserRouter
2 路由组件：包裹整个应用：一个React应用只使用一次
3 HashRouter：使用URL的哈希值实现，就是在地址栏的后面有#（localhost:3000/#/sdjdjdj）
4 推荐使用BrowserRouter：使用H5的historyAPI实现（localhost:3000/djjdd）
5 Link:组件：用于指定导航链接（a标签） 在浏览器解析时，会将link组件解析成a标签
6 Router组件：指定路由展示相关的组件信息
```

#### React路由传参方法

```
  通过params
        1.路由表中
              <Route path=' /sort/:id '   component={Sort}></Route>
        2.Link处
          HTML方式
                 <Link to={ ' /sort/ ' + ' 2 ' }  activeClassName='active'>XXXX</Link>
          JS方式
                this.props.history.push(  '/sort/'+'2'  )
        3.sort页面
               通过  this.props.match.params.id        就可以接受到传递过来的参数（id）
  通过query
      前提：必须由其他页面跳过来，参数才会被传递过来
　　　 注：不需要配置路由表。路由表中的内容照常：<Route path='/sort' component={Sort}></Route>
        1.Link处
         HTML方式
            <Link to={{ path : ' /sort ' , query : { name : 'sunny' }}}>
       JS方式
            this.props.history.push({ path : '/sort' ,query : { name: ' sunny'} })
        2.sort页面
              this.props.location.query.name
```
